# 第三章

### 可执行脚本

在python代码文件顶端加上：

```
#!/usr/bin/python
```

指出了python解释器的路径，这样该文件就成为了一个可执行脚本。



为了避免硬编码python解释器的路径，可以这么写：

```
#!/usr/bin/env python
```

env程序会通过系统的搜索路径的设置（一般为PATH环境变量中的目录）定位python解释器，增强了代码的可移植性。



在Windows中，这句话会被简单地忽略，不影响程序正确性。



### 导入和重载

每一个以.py拓展名结尾的Python源代码文件都是一个模块。

导入一个文件(import)会立刻执行该文件

可以使用`reload()`函数再次执行一个已导入的文件。

```
import brian
from imp import reload
reload(brian)
```



直接使用`import`，需要使用模块名.属性访问其中的变量；使用`from module import attribute` 导入则可以直接使用变量名。这是因为每个通过`import`引入的模块都有一个自己的命名空间。



`dir(module)`返回该模块中的变量名列表。



也可使用`exec(open('filename').read())`来执行另一个python文件，这样做相当于把文件内容粘贴到了调用exec处，不会产生新的命名空间。因此当前正在使用的同名变量可能被覆盖掉。



# 第四章

Python中的一切都是对象。



### 索引

负的索引号会与序列的长度相加，$s[-1]$即$s[len(s)-1]$

分片：$X[i:j:k]$为偏移量为$[i:j)$的子序列，按步长k进行提取，$i$默认为0，$j$默认为$len(X)$，$k$默认为1.



$k$也可以为负数，这种情况下分片从右往左进行，因此$i$应该大于$j$.

### 不可变性

数字、字符串和元组是不可变的对象，他们在创建后不能原址(in place)改变。

列表、字典和集合是可变对象。

字符串的方法（如find, replace）不会改变原始字符串，而会创建一个新的字符串作为结果。



可以使用`help()`函数查看一个对象（包括函数）的用法。



给不存在于字典中的键赋值会增加该键，但不能访问一个不存在的键值。



# 第五章

0x十六进制，0o八进制，0b二进制



允许链式比较`X < Y < Z == (X < Y) and (Y<Z)`



Python3中地板除`//`向下取整(不是向0)，但返回值未必是整数。若其中一个操作数是浮点数，结果也是浮点数。

```
10 / 4 == 2
10 / 4.0 == 2.0
```

使用int()或math.trunc()函数可实现向0的舍入。



复数可表示为`a+bj`的形式。

小数由模块decimal支持，本质是精度固定的浮点数。

分数由模块fractions支持，显式维持了一个分子和一个分母。



集合只能包含不可变的（可哈希的）对象，因此不能存入列表和字典。

可以用它frozenset创建不可变的集合，它可以被存入另一个集合。



# 第六章

变量是一个系统表的入口，包含了指向对象的链接。

对象是被分配到的一块内存，有足够空间表示它们所代表的值。

引用是自动形成的从变量到对象的指针。



对象包含两个头部信息：类型标识符和引用计数器。因此类型与对象相关联，而非与变量相关联。



未被其他变量名或对象引用的对象所占用的空间会被自动回收。小整数或短字符串可能会被缓存复用，因此不会被立刻回收。



对列表、字典、集合的修改会在原址改变对象，因此若想要深拷贝一个列表，应该使用从头到尾的分片。若想深拷贝一个字典或集合，可以使用.copy()方法。

​	注意：无参数的分片和copy方法只能进行顶层复制，不能复制嵌套的数据结构（如列表中嵌套列表），如果要	对嵌套的数据结构进行完整的复制，应该使用标准库copy模块。

```
import copy
X = copy.deepcopy(Y)
```



```
X=42
Y=42
X == Y	#True
X is Y 	#True

X=[1,2,3]
Y=[1,2,3]
X == Y #True
X is Y #False
```

这是因为小的整数和字符串被缓存复用，X和Y指向了相同的对象



# 第七章

表达式中相邻的字符串会被自动拼接，除非用逗号隔开



字母r（大写或小写）出现在字符串的第一引号前面，将会关闭转义机制，反斜杠会被作为字面量来保持

（一个原始字符串不能以'\\'结尾，这会导致最后一个引号被转义）



被三引号包围的任意行数的文本，会被收集到一个单独字符串中，并在行转折处嵌入换行符，于是打印出来的格式与在代码中输入的一致，所见即所得

也可以用三引号包围代码实现注释的效果，因为Python会用被包围的代码创建字符串



`ord()`函数接收单个字符，返回其ascii码；`chr()`函数是其逆操作



`join()`方法接受一个可迭代对象作为参数，将其中的字符串连在一起，并用给定的分隔符隔开

```
>>>('S'.join(['1','2','3'])	
1S2S3
```



`split()`方法将一个字符串从给定的分隔符处切成一系列子串



### 格式化表达式

```
%[(keyname)][flags][width][.precision]typecode
```

其中`keyname`为索引在表达式右侧使用的字典提供键名称；`flags`罗列说明格式的标签；`width`为被替换文本给出最小宽度；`precision`为浮点数设置小数点后的位数（精度）

部分flags：

| flags  | 作用                                   |
| ------ | -------------------------------------- |
| -      | 左对齐                                 |
| +      | 数值符号（正数显示正号，负数显示负号） |
| `空格` | 正数显示空格，负数显示负号             |
| 0      | 用0填充至要求的宽度                    |

可以用*占位`width`和`precision`，指示它们从右侧元组中取得两个参数的值：

```
>>>'%.*f' % (3,3.14)
3.140
```



基于字典的格式化表达式：

​	注意：这里`%(qty)d`中的qty就是`keyname`

```
>>>'%(qty)d more %(food)s' % {'qty':1, 'food': 'spam'} 
1 more spam
```

`vars()`函数返回一个字典，包含被调用处所有存在的变量及其值，可以与之配合使用



### 格式化方法

替代目标的形式化结构：

```
{fieldname component !conversionflag :formatspec}
```

`fieldname`是一个辨识参数的数字（十进制非负整数）或关键字，它可以被省略，按照出现顺序默认编号

​	注意：花括号个数可以小于位置参数的个数，反之不然

​	注意：使用数字相当于把format中所有位置参数当成一个元组，进行索引取值

​	注意：可以混合使用数字形式和变量名形式的字段名，但关键字参数必须位于位置参数之后

​	注意：混合使用时可以省略数字，但省略数字的字段名`{}`不能与数字字段名`{非负整数}`同时使用。

`component`包括".name"或"[index]"，用来访问参数的属性或索引值

​	注意：index只能是一个非负数，不能使用负数索引值以及分片，要实现它们需要在格式化字符串之外进行

`conversionflag`如果出现则以!开始，后面跟着r,s或者a，在这个值上分别调用`repr`,`str`或`ascii`内置函数

`formatspec`如果出现则以:开始，指示了如何表示该值。形式如下：

```
[[fill]align][sign][#][0][width][,][.precision][typecode]
```

`fill`为可选的填充字符，默认为空格，一旦指定填充字符，必须同时指定对齐方式`align`

`align`可为<,>,=,^，分别表示左对齐，右对齐，在符号字符后填充，居中对齐

​	注意：必须给出`width`，否则对齐方式没有意义

`sign`可以为+,-,`空格`，作用与格式化表达式中一致

`width`,`precision`,`typecode`也与格式化表达式中一致(`typecode`还额外允许`b`类型码，二进制)

`0`位于`width`前，表示可选的零填充，等价于指定了`0=`的填充与对齐方式

`#`为二进制、八进制、十六进制数分别加上`0b` `0o` `0x`前缀

`,`表示分组选项：

​	逗号','表示千分位分隔符，即从个位开始每隔3位加逗号

​	下划线'_'为浮点数和以`d`打印的整数，每隔3位加下划线，与逗号类似，对于以`b` `o` `x` `X`打印的二、八、十	六进制数，每隔四位加下划线



注意：在替代目标字符串中，花括号`{` `}`需要用花括号本身转义

```
>>>'{{{0}}}'.format(1)
{1}
```



格式化方法使用component示例：

```
>>>import sys
>>>'My {1[kind]} runs {0.platform}'.format(sys, {'kind': 'laptop'})
My laptop runs linux
```



# 第八章

`sort`方法是原址排序，内置函数`sorted`则会返回一个新序列，`sorted()`可以对任意可迭代对象使用。



`extend`方法循环访问传入的可迭代对象，并把产生的元素逐个添加到列表尾部；`append`方法直接把传入的对象添加到尾部



分片赋值可以理解为先删除再插入。把空列表赋值给分片会删除列表片段，但把空列表赋值给索引则会在指定位置存储空列表对象的引用

```
>>>L=[1,2,3]
>>>L[1:]=[]
>>>L
[1]
>>>L[0]=[]
>>>L
[[]]
```



in成员运算符可以用于字典，`for key in D`和`for key in D.keys()`效果一样



字典的键必须是不可变（可哈希）的对象，因此列表、集合、字典不能作为键，但可以作为值



Python 3.X中，字典的`keys()` `values()` `items()`方法返回视图对象而非列表，它们能动态反映视图对象创建之后对字典的修改。其中方法`keys()`返回的集合对象支持集合操作



# 第九章

元组的不可变性只适用于元组顶层而非其内容，例如元组内部的列表是可以修改的

```
>>>T = (1,[2,3],4)
>>>T[1][0]=5
>>>T
(1,[5,3],4)
```



文件内容被读入程序时是一个字符串，使用pickle,json存储Python对象



比较列表和元组：从左到右比较每个组件的内容，对嵌套结构的比较是递归的，直至末尾或发现第一处区别

```
>>>[2] > [1,2]
True
```

比较集合：若a是b的子集则a<b，a是b的超集则a>b

字典可以判断相同，在Python 3.X中不能比较大小，在Python 2.X中通过比较排序后的(key,value)列表比较大小



True和False是每个Python对象的固有属性，非真既假。

​	数字如果等于0则为假，反之为真。

​	其他对象如果为空则为假，反之为真。



# 第十章

分号用于在一行内分隔多个语句，括号用于把一个语句拆分到多行



简单语句可以直接跟在冒号后面作为嵌套代码块：

```
if x>y: print(x)
```



同一个嵌套语句块中的语句必须缩进相同距离



# 第十一章

### 序列赋值

可以将任何值的序列复制给任何序列，按照位置把左侧的目标和右侧的对象从左至右配对

```
x, y = 1, 2
a,b,c,d = 'spam'
```

因为Python会为右侧变量原本的值创建一个临时元组，因此`x, y = y, x `可以交换两个变量的值

Python 3.x中可以在赋值目标中使用带*的名称，它会被赋值为一个列表，包含未被赋值给其他名称的所有项

```
>>>a, *b, c=(1,2,3,4)
>>>a
1
>>>b
[2,3]
>>>c
4
```

​	注意：如果带*的名称匹配到单个项，会被赋值为单元素列表；如果没有匹配到项，会被赋值为空列表

​	注意：带*的名称必须位于一个列表中

```
>>>*a=(1,2,3)
SyntaxError
>>>*a, = (1,2,3)
>>>a
[1,2,3]
```



多目标赋值：各变量指向同一个对象，因此用这种方法初始化可变类型对象时，各变量会互相影响



增量赋值运算符(如+=)对于支持原位置修改的对象(如列表)会选择执行原位置修改运算(如调用extend)，而非更慢的复制运算，所以"+="不一定就等于"+"和"="

```
L += [9,10]    #Mapped to L.extend([9,10])
```



以单一下划线开头的名称(_X)不会被`from module import *`语句导入

前后均有双下划线的名称(\_\_X\_\_)是系统定义的名称



`print`调用形式：

```
print([object, ...][, sep=' '][, end='\n'][, file=sys.stdout][, flush=False])
```

`sep`是在每个对象的文本之间插入的字符串，作为分隔符

`end`是添加在打印文本末尾的一个字符串

`file`指定文本将要发送到文件、标准流，或其他类似文件的对象

`flush`允许`print`强制刷新输出流



`print(X,Y)`等价于：

```
import sys
sys.stdout.write(str(X) + ' ' + str(Y) + '\n')
```

`print`是`sys.stdout`对象的简单接口，再加上一些默认的格式设置

如果使用`sys.stdout=`将其重设，之后所有`print`都会被重定向



# 第十二章

混用空格和制表符来缩进会导致报错



and和or运算并非返回True或False

and运算从左到右计算操作数，并返回第一个为假的对象；or运算从左到右计算操作数，并返回第一个为真的对象

如果没有为假/真的对象，会返回最后一个对象

这种行为是因为遇到的第一个假/真对象已经足以确定整个表达式的真假



三元选择表达式：

```
if X:
	A = Y
else:
	A = Z
```

等价于`A = Y if X else Z`或`A = ((X and Y) or Z)`

甚至可以写`A = [Z,Y](bool(X))`，但这不完全等价，因为不论X真与假，Z和Y都被计算，并不是短路的



用类定义新类型时，布尔特性由`__bool__`方法确定。如果它未被定义，就由`__len__`方法确定（返回长度）



# 第十三章

循环`else`分句：当且仅当循环正常离开（没有碰到`break`语句时执行）

Python 3.X中也可以用`...`来省略代码，作用类似于`pass`或`None`，起到占位作用



Python中的赋值语句只是语句而非表达式，因此不能写C风格的`while( (x = next()) != NULL)`



for语句：`for target in object`，逐个将可迭代对象`object`中的元素赋值给名称`target`，然后执行循环体



`zip()`函数接受N个序列作为参数，返回将这些序列中并排的元素配对，所得到的N元素元组的列表

可以使用`dict(zip(keys,vals))`创建字典



`enumerate()`函数返回一个生成器对象，在每次迭代中返回一个(index, value)元组



# 第十四章

`iter(f)`和`next(f)`调用对象的方法，分别相当于`f.__iter__()`和`f.__next__()`



`__next__()`方法被调用时，对象前进到下一个结果。若已到达结果的末尾，引发`StopIteration`异常



可迭代对象(iterable)：支持`iter()`调用的对象，在迭代过程中被`iter()`调用以返回迭代器对象

迭代器对象(iterator)：可迭代对象的返回结果，在迭代过程中实际提供值



文件对象自身就是迭代器，只支持一次迭代；列表等是可迭代对象，支持多次迭代

```
>>>f=open('test.py')
>>>L=[1,2,3]
>>>iter(f) is f
True
>>>iter(L) is L
False
```



使用for循环来遍历文件对象，每次读取一行，避免了一次将整个文件载入内存。

```
for line in open('script2.py')
```



### 手动迭代

```
L=[1,2,3]
for X in L:
	print(X)
```

相当于：

```
L=[1,2,3]
It= iter(L)
while True:
	try:
		X=next(It)
	except StopIteration:
		break
	print(X)
```



列表推导中的for循环可以有一个if分句`[x for x in L if x != 0]`

也可以嵌套for循环`[x+y for x in L1 for y in L2]`等价于：

```
res = []
for x in L1:
	for y in L2:
		res.append(x+y)
```



`map()`函数接受一个函数和一个可迭代对象作为参数，将该函数应用于可迭代对象中的每一项，它本身返回一个可迭代对象，因此必须用一个`list()`调用包含它，才能使它一次给出所有值



函数调用中使用\*arg把一个集合的值解包为单个的参数，于是`zip(*zip(x,y))`实现了zip的逆运算（矩阵转置两次）



`range()`返回对象本身不是迭代器，它可以被多遍遍历；`zip()` `map()` `fliter()`返回对象是迭代器，只能遍历一次



# 第十五章

出现在文件顶端，函数和类的开头的字符串（文档字符串）会被自动装载为相应对象的`__doc__`属性

使用`help()`函数查看到的内容也包含文档字符串的信息



# 第十六章

